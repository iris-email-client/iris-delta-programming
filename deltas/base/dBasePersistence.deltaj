delta dBasePersistence {
	adds {
		package br.unb.cic.iris.persistence;
		
		import br.unb.cic.iris.core.exception.DBException;
		import br.unb.cic.iris.core.model.AddressBookEntry;
		
		/**
		 * A DAO for address books. 
		 * 
		 * @author modularidade
		 *
		 */
		public interface IAddressBookDAO {
		
			public void save(AddressBookEntry entry) throws DBException;
			
			public AddressBookEntry find(String nick) throws DBException;
			
			public void delete(String nick) throws DBException;
		}		
	}
	adds {
		/*
		 * EmailDAO.java
		 * ---------------------------------
		 *  version: 0.0.1
		 *  date: Sep 18, 2014
		 *  author: rbonifacio
		 *  list of changes: (none) 
		 */
		package br.unb.cic.iris.persistence;
		
		import java.util.Date;
		
		import br.unb.cic.iris.core.exception.DBException;
		import br.unb.cic.iris.core.model.EmailMessage;
		
		/**
		 * A DAO for electronic e-mail messages. Note that the current version of the
		 * persistence concern is quite simple. Indeed, we have only one persistent
		 * class (an email message).
		 * 
		 * @author rbonifacio
		 */
		public interface IEmailDAO {
		
			/**
			 * Saves an email message into the database.
			 * 
			 * @param message
			 */
			public void saveMessage(EmailMessage message) throws DBException;
			
			public Date lastMessageReceived() throws DBException;
		
		}		
	}
	adds {
		package br.unb.cic.iris.persistence;
		
		public interface IFolderDAO {
		
		}			
	}
	adds {
		package br.unb.cic.iris.persistence.sqlite3;
		
		import java.lang.reflect.ParameterizedType;
		import java.util.List;
		
		import org.hibernate.HibernateException;
		import org.hibernate.Query;
		import org.hibernate.Session;
		import org.hibernate.criterion.MatchMode;
		
		import br.unb.cic.iris.core.exception.DBException;
		import br.unb.cic.iris.util.HibernateUtil;
		
		public abstract class AbstractDAO<T> {
			private Class<T> clazz;
			protected Session session;
			
			public AbstractDAO(){
				clazz = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];
				System.out.println("******************************** CLAZZ="+clazz);
			}
			
			public void saveOrUpdate(T obj) throws DBException {
		        try {
		            startSession();
		            session.saveOrUpdate(obj);
		            session.getTransaction().commit();
		        } catch (HibernateException e) {
		            handleException(e);
		        } finally {
		        	closeSession();
		        }
		    }
			
			public void delete(T t) throws DBException {
				try {
		            startSession();
		            session.delete(t);
		            session.getTransaction().commit();
		        } catch (HibernateException e) {
		            handleException(e);
		        } finally {
		        	closeSession();
		        }
			}
			
			public T findById(Long id) throws DBException {
		        T obj = null;
		        try {
		            startSession();
		            obj = (T) session.load(clazz, id);
		            session.getTransaction().commit();
		        } catch (HibernateException e) {
		            handleException(e);
		        } finally {
		        	closeSession();
		        }
		        return obj;
		    }
		
		    public List<T> findAll() throws DBException {
		        List<T> objects = null;
		        try {
		            startSession();
		            Query query = session.createQuery("from " + clazz.getName());
		            objects = query.list();
		            session.getTransaction().commit();
		        } catch (HibernateException e) {
		            handleException(e);
		        } finally {
		        	closeSession();
		        }
		        return objects;
		    }
		
			public List<T> findByExample(T filtro, MatchMode matchMode, boolean ignoreCase){
				org.hibernate.criterion.Example example = org.hibernate.criterion.Example.create(filtro);
		
				if(matchMode != null){
					example = example.enableLike(matchMode);
				}
		
				if(ignoreCase){
					example = example.ignoreCase();
				}
		
				return session.createCriteria(clazz).add(example).list();
			}
			
			protected void handleException(Exception e) throws DBException {
				session.getTransaction().rollback();
		        throw new DBException(e.getMessage(), e);
		    }
		
		    protected void startSession() throws HibernateException {
		        session = HibernateUtil.getSessionFactory().openSession();
		        session.beginTransaction();
		    }
		    
			protected void closeSession() {
				if(session != null && session.isOpen()) {
					session.flush();
					session.close();
				}
			}
		}		
	}

	adds {
		package br.unb.cic.iris.persistence.sqlite3;
		
		import java.util.List;
		
		import br.unb.cic.iris.core.exception.DBException;
		import br.unb.cic.iris.core.model.AddressBookEntry;
		import br.unb.cic.iris.persistence.IAddressBookDAO;
		
		public final class AddressBookDAO extends AbstractDAO<AddressBookEntry> implements IAddressBookDAO {
				
			private static final String FIND_BY_NICK_NAME = 
					"FROM AddressBookEntry a "
					+ "where a.nick = :pNick";
			
			
			private static AddressBookDAO instance; 
			
			private AddressBookDAO() { } 
			
			public static AddressBookDAO instance() {
				if(instance == null) {
					instance = new AddressBookDAO();
				}
				return instance;
			}
			
			
			@Override
			public void save(AddressBookEntry entry) throws DBException{
				super.saveOrUpdate(entry);
			}
		
			
			@Override
			public AddressBookEntry find(String nick) throws DBException {
				try {
					//session = HibernateUtil.getSessionFactory().openSession();
					startSession();
					List<AddressBookEntry> entries = session.createQuery(FIND_BY_NICK_NAME).setParameter("pNick", nick).list();
					
					if(entries != null && entries.size() == 1) {
						return entries.get(0);
					}
					return null;
				} catch(Exception e) {
					throw new DBException("could not save the address book entry", e);	
				} finally {
					closeSession();
				}
			}
		
			@Override
			public void delete(String nick) throws DBException {
				AddressBookEntry entry = find(nick);
				if(entry != null){
					super.delete(entry);
				}
			}
		
		}		
	}
	
	adds {
		/*
		 * EmailDAO.java
		 * ---------------------------------
		 *  version: 0.0.1
		 *  date: Sep 18, 2014
		 *  author: rbonifacio
		 *  list of changes: (none) 
		 */
		package br.unb.cic.iris.persistence.sqlite3;
		
		import java.util.Date;
		import java.util.List;
		
		import org.hibernate.HibernateException;
		
		import br.unb.cic.iris.core.exception.DBException;
		import br.unb.cic.iris.core.model.AddressBookEntry;
		import br.unb.cic.iris.core.model.EmailMessage;
		import br.unb.cic.iris.persistence.IEmailDAO;
		
		/**
		 * An implementation of @see br.unb.cic.iris.persistence.EmailDAO using the SQLite databaese.
		 * 
		 * @author rbonifacio
		 *
		 */
		public final class EmailDAO extends AbstractDAO<EmailMessage> implements IEmailDAO {
			private static final String FIND_MAX_DATE = "select max(e.date) FROM EmailMessage e";
			// select o from LoadFileHistory o where o.finishDate > :today
		
			/* the single instance of EmailDAO */
			private static EmailDAO instance = new EmailDAO();
		
			/* private constructor, according to the singleton pattern */
			private EmailDAO() {
			}
		
			/**
			 * Retrieves the singleton instance of EmailDAO.
			 * 
			 * @return the singleton instance of EmailDAO
			 */
			public static EmailDAO instance() {
				return instance;
			}
		
			@Override
			public void saveMessage(EmailMessage message) throws DBException {
				super.saveOrUpdate(message);
			}
		
			@Override
			public Date lastMessageReceived() throws DBException {
				Date date = null;
				try {
					startSession();
					date = (Date) session.createQuery(FIND_MAX_DATE).uniqueResult();
				} finally {
					closeSession();
				}
				return date;
			}
		
		}		
	}
	
	adds {
		package br.unb.cic.iris.persistence.sqlite3;
		
		import static br.unb.cic.iris.i18n.Message.message;
		
		import java.util.List;
		
		import br.unb.cic.iris.core.exception.DBException;
		import br.unb.cic.iris.core.model.IrisFolder;
		import br.unb.cic.iris.persistence.IFolderDAO;
		
		public class FolderDAO extends AbstractDAO<IrisFolder> implements IFolderDAO {
			private static final String FIND_BY_NAME = "FROM IrisFolder f " + "where f.name = :pName";
		
			public IrisFolder findByName(String folderName) throws DBException {
				try {
					startSession();
					List<IrisFolder> entries = session.createQuery(FIND_BY_NAME).setParameter("pName", folderName).list();
		
					if (entries != null && entries.size() == 1) {
						return entries.get(0);
					}
					return null;
				} catch (Exception e) {
					throw new DBException(message("error.folder.not.found", folderName), e);
				} finally {
					closeSession();
				}
			}
		}		
	}
}