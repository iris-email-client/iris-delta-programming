delta dPersistenceLucene {
	modifies br.unb.cic.iris.command.console.DownloadMessagesConsoleCommand {
		adds import br.unb.cic.iris.persistence.lucene.EmailDAO;		
	}
	modifies br.unb.cic.iris.core.FolderManager{
		adds import br.unb.cic.iris.persistence.lucene.EmailDAO;
		adds import br.unb.cic.iris.persistence.lucene.FolderDAO;		
	}
	modifies br.unb.cic.iris.core.SystemFacade {
		adds import br.unb.cic.iris.persistence.lucene.EmailDAO;
		adds import br.unb.cic.iris.persistence.lucene.FolderDAO;		
	}

	/*
	adds {
		package br.unb.cic.iris.persistence.sqlite3;
		
		import java.lang.reflect.ParameterizedType;
		import java.util.List;
		
		import org.hibernate.HibernateException;
		import org.hibernate.Query;
		import org.hibernate.Session;
		import org.hibernate.criterion.MatchMode;
		
		import br.unb.cic.iris.core.exception.DBException;
		import br.unb.cic.iris.util.HibernateUtil;
		
		public abstract class AbstractDAO<T> {
			private Class<T> clazz;
			protected Session session;
			
			public AbstractDAO(){
				clazz = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];
			}
			
			public void saveOrUpdate(T obj) throws DBException {
		        try {
		            startSession();
		            session.saveOrUpdate(obj);
		            session.getTransaction().commit();
		        } catch (HibernateException e) {
		            handleException(e);
		        } finally {
		        	closeSession();
		        }
		    }
			
			public void delete(T t) throws DBException {
				try {
		            startSession();
		            session.delete(t);
		            session.getTransaction().commit();
		        } catch (HibernateException e) {
		            handleException(e);
		        } finally {
		        	closeSession();
		        }
			}
			
			public T findById(Long id) throws DBException {
		        T obj = null;
		        try {
		            startSession();
		            obj = (T) session.load(clazz, id);
		            session.getTransaction().commit();
		        } catch (HibernateException e) {
		            handleException(e);
		        } finally {
		        	closeSession();
		        }
		        return obj;
		    }
		
		    public List<T> findAll() throws DBException {
		        List<T> objects = null;
		        try {
		            startSession();
		            Query query = session.createQuery("from " + clazz.getName());
		            objects = query.list();
		            session.getTransaction().commit();
		        } catch (HibernateException e) {
		            handleException(e);
		        } finally {
		        	closeSession();
		        }
		        return objects;
		    }
		
			public List<T> findByExample(T filtro, MatchMode matchMode, boolean ignoreCase){
				org.hibernate.criterion.Example example = org.hibernate.criterion.Example.create(filtro);
		
				if(matchMode != null){
					example = example.enableLike(matchMode);
				}
		
				if(ignoreCase){
					example = example.ignoreCase();
				}
		
				return session.createCriteria(clazz).add(example).list();
			}
			
			protected void handleException(Exception e) throws DBException {
				session.getTransaction().rollback();
		        throw new DBException(e.getMessage(), e);
		    }
		
		    protected void startSession() throws HibernateException {
		        session = HibernateUtil.getSessionFactory().openSession();
		        session.beginTransaction();
		    }
		    
			protected void closeSession() {
				if(session != null && session.isOpen()) {
					session.flush();
					session.close();
				}
			}
		}		
	}
	*/
	adds {
		package br.unb.cic.iris.persistence.lucene;
		
		import java.io.File;
		import java.io.IOException;
		import java.text.ParseException;
		import java.util.Date;
		import java.util.List;
				
		import org.apache.lucene.analysis.Analyzer;
		import org.apache.lucene.analysis.standard.StandardAnalyzer;
		import org.apache.lucene.document.DateTools;
		import org.apache.lucene.document.Document;
		import org.apache.lucene.document.Field;
		import org.apache.lucene.document.IntField;
		import org.apache.lucene.document.Field.Store;
		import org.apache.lucene.document.LongField;
		import org.apache.lucene.document.StringField;
		import org.apache.lucene.document.TextField;
		import org.apache.lucene.index.DirectoryReader;
		import org.apache.lucene.index.IndexWriter;
		import org.apache.lucene.index.IndexWriterConfig;
		import org.apache.lucene.index.Term;
		import org.apache.lucene.search.IndexSearcher;
		import org.apache.lucene.search.Query;
		import org.apache.lucene.search.Sort;
		import org.apache.lucene.search.SortField;
		import org.apache.lucene.search.SortField.Type;
		import org.apache.lucene.search.TermQuery;
		import org.apache.lucene.search.TopFieldDocs;		
		import org.apache.lucene.queryparser.classic.QueryParser;
		import org.apache.lucene.search.IndexSearcher;
		import org.apache.lucene.search.Query;
		import org.apache.lucene.search.ScoreDoc;
		import org.apache.lucene.store.Directory;
		import org.apache.lucene.store.FSDirectory;
		import org.apache.lucene.util.Version;

		import br.unb.cic.iris.core.exception.DBException;
		import br.unb.cic.iris.core.model.EmailMessage;
		import br.unb.cic.iris.persistence.IEmailDAO;
		import br.unb.cic.iris.core.model.IrisFolder;
		
		/**
		 * An implementation of @see br.unb.cic.iris.persistence.EmailDAO using Lucene.
		 *
		 */
		public final class EmailDAO /*extends AbstractDAO<EmailMessage>*/ implements IEmailDAO {
		
			/* the single instance of EmailDAO */
			private static EmailDAO instance = new EmailDAO();
		
			/* private constructor, according to the singleton pattern */
			private EmailDAO() {
			}
		
			/**
			 * Retrieves the singleton instance of EmailDAO.
			 * 
			 * @return the singleton instance of EmailDAO
			 */
			public static EmailDAO instance() {
				return instance;
			}
		
			@Override
			public void saveMessage(EmailMessage m) throws DBException {
				Document doc = new Document();
				doc.add(new StringField("type", "email", Store.NO));
				doc.add(new StringField("from", m.getFrom(), Store.YES));
				doc.add(new StringField("to", m.getTo(), Store.YES));
				doc.add(new StringField("cc", m.getCc(), Store.YES));
				doc.add(new StringField("bcc", m.getBcc(), Store.YES));
				doc.add(new TextField("subject", m.getSubject(), Store.YES));
				doc.add(new TextField("message", m.getMessage(), Store.YES));
				doc.add(new StringField("date", DateTools.dateToString(m.getDate(),
						DateTools.Resolution.SECOND), Store.YES));
				doc.add(new LongField("folderId", m.getFolder().getId().longValue(), Store.YES));
				saveDocument(doc);
			}
		
			@Override
			public Date lastMessageReceived() throws DBException {
				Date date = null;
				try {
					// Retrieves only documents whose 'type' is 'email'.
					Query query = new TermQuery(new Term("type", "email"));
					// Sorts documents by date (in descending order).
					Sort sort = new Sort(new SortField("date", Type.STRING, true));
					
					IndexSearcher searcher = IndexManager.getSearcher();
					// Take the top one if it exists.
					TopFieldDocs docs = searcher.search(query, 1, sort);
					if (docs.totalHits > 0) {
						Document doc = searcher.doc(docs.scoreDocs[0].doc);
						date = DateTools.stringToDate(doc.get("date"));
					}
				} catch (IOException e) {
					throw new DBException("An error occurred while retrieving last message received", e);
				} catch (ParseException e) {
					e.printStackTrace();
				}
				
				return date;
			}
			
			public List<EmailMessage> listMessages(Integer idFolder) throws DBException {
				return null;
			}
			
			public List<EmailMessage> findAll() throws DBException {
				return null;
			}
			
			public EmailMessage findById(Long id) throws DBException {
				return null;
			}
			
			protected void saveDocument(Document doc) throws DBException {
				try {
					IndexWriter writer = IndexManager.getWriter();
					writer.addDocument(doc);
					writer.commit();
				} catch (IOException e) {
					throw new DBException("An error occurred while saving e-mail message.", e);
				}
			}
			
			public static void main(String[] args) throws DBException {
				EmailMessage message = new EmailMessage();
				message.setFrom("alexandrelucchesi@gmail.com");
				message.setTo("rbonifacio123@gmail.com");
				message.setCc("jeremiasmg@gmail.com");
				message.setBcc("somebcc@gmail.com");
				message.setSubject("Alexandre Lucchesi");
				message.setMessage("Testing Lucene. :-)");
				message.setDate(new Date());
				message.setFolder(new IrisFolder(19, "UnB"));
				EmailDAO emailDAO = new EmailDAO();
				emailDAO.saveMessage(message);
			}
		
		}		
	}

	adds {
		package br.unb.cic.iris.persistence.lucene;
		
		import java.util.List;
		
		import br.unb.cic.iris.i18n.MessageBundle;
		
		import br.unb.cic.iris.core.exception.DBException;
		import br.unb.cic.iris.core.model.IrisFolder;
		import br.unb.cic.iris.persistence.IFolderDAO;
		
		public class FolderDAO /*extends AbstractDAO<IrisFolder>*/ implements IFolderDAO {

			private static FolderDAO instance;
			
			private FolderDAO(){ }
			
			public static FolderDAO instance(){
				if(instance == null){
					instance = new FolderDAO();
				}
				return instance;
			}

			public IrisFolder findByName(String folderName) throws DBException {
				return null;
			}

			public List<IrisFolder> findAll() throws DBException {
				return null;
			}
			
			public IrisFolder findById(Integer id) throws DBException {
				return null;
			}
		}	
	}	
	
	adds {
		package br.unb.cic.iris.persistence.lucene;
		
		import java.io.File;
		import java.io.IOException;
		
		import org.apache.lucene.analysis.Analyzer;
		import org.apache.lucene.analysis.standard.StandardAnalyzer;
		import org.apache.lucene.document.FieldType;
		import org.apache.lucene.index.DirectoryReader;
		import org.apache.lucene.index.IndexReader;
		import org.apache.lucene.index.IndexWriter;
		import org.apache.lucene.index.IndexWriterConfig;
		import org.apache.lucene.search.IndexSearcher;
		import org.apache.lucene.store.Directory;
		import org.apache.lucene.store.FSDirectory;
		import org.apache.lucene.store.RAMDirectory;
		import org.apache.lucene.util.Version;
		
		public class IndexManager {
		
			/* Indexed, tokenized, stored. */
			public static final FieldType TYPE_STORED = new FieldType();
		
			static {
				TYPE_STORED.setIndexed(true);
				TYPE_STORED.setTokenized(true);
				TYPE_STORED.setStored(true);
				TYPE_STORED.setStoreTermVectors(true);
				TYPE_STORED.setStoreTermVectorPositions(true);
				TYPE_STORED.freeze();
			}
		
			private static Directory index;
			private static IndexWriter writer;
			private static IndexReader reader;
		
			private IndexManager() {
			}
		
			public static Directory createIndex(String filepath) throws IOException {
				File path = null;
				if (filepath != null && !filepath.isEmpty()) {
					path = new File(filepath);
				}
		
				if (path == null || !path.exists())
					index = new RAMDirectory();
				else
					index = FSDirectory.open(path);
		
				return index;
			}
		
			public static void setIndex(String filepath) throws IOException {
				File path = null;
				if (filepath != null && !filepath.isEmpty()) {
					path = new File(filepath);
				}
		
				if (path == null || !path.exists())
					throw new IOException("Couldn't open the specified Lucene index.");
		
				index = FSDirectory.open(path);
			}
		
			public static Directory getIndex() throws IOException {
				if (index == null)
					index = createIndex(null); // Index in RAM
				return index;
			}
		
			public static void closeIndex() throws IOException {
				index.close();
				writer = null;
				index = null;
				reader = null;
			}
		
			public static IndexWriter getWriter() throws IOException {
				if (writer == null) {
					Analyzer analyzer = new StandardAnalyzer();
					IndexWriterConfig config = new IndexWriterConfig(Version.LATEST,
							analyzer);
					writer = new IndexWriter(getIndex(), config);
				}
				return writer;
			}
		
			private static IndexReader getReader() throws IOException {
				if (reader == null) {
					reader = DirectoryReader.open(getIndex());
				} else {
					// The method below ensures we get an updated view of the index. It
					// returns a new reader if the index has changed after we opened the
					// previous reader. Otherwise, it returns 'null'.
					IndexReader r = DirectoryReader.openIfChanged((DirectoryReader) reader);
					if (r != null) reader = r;
				}
				// Line below 
				return reader;
			}
		
			public static IndexSearcher getSearcher() throws IOException {
				// According to the documentation, creating a searcher from an existing
				// reader is cheap.
				return new IndexSearcher(getReader());
			}
		
		}		
	}

}